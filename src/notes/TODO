2000-01-18:

+ The amlazy file Data.sml containing a structure called Data: parse
  as AnonStruct, then resolve in the compiler

* Avoid shift/reduce and reduce/reduce conflicts in the parser.

+ Documentation: 

  - manual
  - syntax

+ Emitcode: switch larger than 256 ?  OK because the switch
  compilation in Back breaks switches into chunks of size < 256

* Size of .ui files: sharing?

+ Kit: It is functor Parse in k42.sml that causes trouble --- even
  when actions in k32.sml is commented out.  Functor Parse is declared
  in k35.sml.  More precisely, the application of functor GrammarUtils
  inside the Parse functor in k35.sml:

    structure GrammarUtils =
      GrammarUtils (structure TopdecGrammar = TopdecGrammar
		    structure LexBasics = LexBasics
		    structure ParseInfo = ParseInfo
		    structure Report = Report
		    structure PrettyPrint = PrettyPrint
		    structure Crash = Crash
		      )
  Functor GrammarUtils is declared in k32.sml.
 
  Problem: open of local decs.

+ Back.sml -- array size 65000 -> 4000 (used only for the locals of 
  the init code)

+ Size of mosmllex and mosmllnk: avoid linking in Types

+ exnName and exnMessage -> runtime

  prim_val exnname : exn -> string = 1 "sml_exnname";

  prim_val exnMessage : exn -> string = 1 "sml_exnmessage";

+ Add documentation to General.fke

+ Implement sharing of literals (strings, reals, etc) as globals cf
  the hol98 and cholera problems: Updated Patch and Reloc and Code_dec
  and Link.

+ Cleanup of the dynlibs; moved stable structures to src/mosmllib

+ Fix mgd dynlib to use new GD package and PNG format.

+ Fix mosmllib/test/Makefile to create sym- and hardlinks as needed

+ Fix errormessage in compiler/Emitcode

+ Fix printing of overloaded ops to distinguish num, numtxt etc

* Fix exn tag access under lambda in Match.sml

* In general, compile better code for accessing subvalues in matches.
  However, should never evaluate accesses that aren't needed (safe but
  unnecessarily slow). The matching function may return an `envelope'
  of let-bindings?

+ Include runtime system *.h files in distribution (for the sake of
  user-written C code and dynlibs)

* Perhaps fix mgdbm to use new GDBM?

+ Inexhaustive and redundant excon matches -- why not reported correctly?
  Because EExn carries IdInfo as argument, and that includes the location 
  of the identifier.  Of course no two identifier occurrences have the same 
  location.  How fix it?  Translate the exnname accesses early, and
  compare the access paths (the lambda code): equal access paths must
  produce equal string refs...

* Add an Odbc interface to unixODBC.
  Later; possibly Thomas Iversen, DIKU/KVL.

+ .h files in mosml/include

+ make dynlibs/* refer to mosml/include

+ move .so files from mosml/bin to mosml/lib

+ strange bug in dynlibs/interface/ for Solaris.  Crashes.  Fails
  test7, because it doesn't pass the fifth argument (a boolean)
  correctly.  test 7 works if the number of arguments is reduced to 4.
  test10 fails as well, why?  NON-BUG.  A symbolic link had been
  extended by recursive file copying.

+ Non-blocking IO in TextIO.  input calls fast_input, which is
  io.input in the runtime.  It calls getblock, which may call
  really_read if necessary to obtain data not in the buffer; and
  really_read calls Unix read.  This will raise sys_error in case Unix
  read fails (cannot obtain any data).

  Two solutions: (1) handle the SysError (and check that it is
  EAGAIN), or (2) add an extra parameter to really_read so that it
  avoids raising the SysError.

  (1) is inefficient, 

  (2) may be done as follows: Add a new boolean parameter `nonblocking' to
  really_read.  If it is true, then use fcntl to change to
  non-blocking (and back), and if read fails, return -1 instead of
  raising sys_error.

  void nonblocking_mode(int fd, int nonblocking) {
    int retcode = fcntl(fd, F_GETFL);
    if (retcode != -1) {
      if (blocking) 
        retcode = fcntl(fd, F_SETFL, retcode | O_NONBLOCK);
      else
        retcode = fcntl(fd, F_SETFL, retcode & (~O_NONBLOCK));
    }
    if (retcode == -1)
      failwith("set_blocking_io");
  }

  static int really_read(int fd, char * p, unsigned n, int nonblocking) {
    if (nonblocking)
      nonblocking_mode(fd, TRUE);		/* set non-blocking   */

    ...

    leave_blocking_section();
    if (nonblocking) {
      nonblocking_mode(fd, FALSE);		/* unset non-blocking */
      if (retcode == -1 && errno != EAGAIN)
        sys_error(NULL);
    } else if (retcode == -1)
        sys_error(NULL);
    return retcode;
  }

  Function input_scan_line must call really_read with nonblocking = false.

  Add a new parameter nonblocking to getblock.  It must be passed on
  to really_read.  Getblock must check whether really_read returns
  -1, which should be treated the same as 0, except that it does not mean 
  end of file:

int getblock(struct channel * channel, char * p, unsigned n, 
   int nonblocking)
{
  unsigned m, l;

  m = channel->max - channel->curr;
  if (n <= m) {
    bcopy(channel->curr, p, n);
    channel->curr += n;
    return n;
  } else if (m > 0) {
    bcopy(channel->curr, p, m);
    channel->curr += m;
    return m;
  } else if (n < IO_BUFFER_SIZE) {
    l = really_read(channel->fd, channel->buff, IO_BUFFER_SIZE, nonblocking);
    if (l == -1) /* Non-blocking read returned no data */ 
      return -1;
    else {
      channel->offset += l;
      channel->max = channel->buff + l;
      if (n > l) n = l;
      bcopy(channel->buff, p, n);
      channel->curr = channel->buff + n;
      return n;
    }
  } else {
    channel->curr = channel->buff;
    channel->max = channel->buff;
    l = really_read(channel->fd, p, n, nonblocking);
    if (l == -1)	/* Non-blocking read returned no data */ 
      return -1;
    else {
      channel->offset += l;
      return l;
    }
  }
}

Function input will just call getblock with non-blocking = FALSE:

value input(value channel, value buff, value start, value length) /* ML */
{
  return Val_long(getblock((struct channel *) channel,
                           &Byte(buff, Long_val(start)),
                           (unsigned) Long_val(length),
	                   /* nonblocking = */ FALSE));
}



Make really_getblock call getblock with nonblocking=FALSE:

int really_getblock(struct channel * chan, char * p, unsigned long n)
{
  unsigned r;
  while (n > 0) {
    r = (unsigned)getblock(chan, p, (unsigned) n, /* nonblocking = */ FALSE);
    if (r == 0) return 0;
    p += r;
    n -= r;
  }
  return 1;
}


  Add a new function input_nonblocking, which will call getblock with
  nonblocking=TRUE.  Returns NONE if getblock returns -1, otherwise 
  returns SOME 

value input_nonblocking(value channel, value buff, value start, value length) /* ML */
{ int n = getblock((struct channel *) channel,
                   &Byte(buff, Long_val(start)),
                   (unsigned) Long_val(length),
	           /* nonblocking = */ TRUE));
  if (n == -1)		/* Non-blocking read returned no data */ 
    return Val_NONE;
  else {
    value res = alloc(1, SOMEtag);
    Field(res, 0) = Val_long(n);
    return res;
  }
}

  
* 2000-03-15 Ken: Parametre til lexer-funktioner

  rule comment depth = parse ...

  for at kunne lave en rent funktionel lexing af indlejrede kommentarer.

+ 2000-03-28: Add a parser combinator module called Parse.
  Reimplement to use NONE/SOME instead of exceptions.  

  Add a formatting (unparsing) module called Format, using Olivier's
  ideas but avoiding repeated string concatenation (e.g. using a
  wseq-like structure) and having also a prsep style
  iterator-with-separator plus an prmap style iterator.

  May 2000: Decided to create mosml/example/parsercomb instead, as the
  parser combinator stuff seems too volatile.

+ Meta.fke;  remove Meta.system

+ Meta.fke; documentation

+ Lexing.sig

+ Parsing.sig

+ mosmllib/README

+ TextIO.scanStream -- get rid of cs? -- no: cannot

* Should gc time be subtracted from sys time?  (Timer, Mosml)

* Non-blocking IO should have a function canInput : int -> SOME int instead.

http://www.dina.kvl.dk/~sestoft/sml/imperative-io.html#IMPERATIVE_IO:SIG:SPEC

+ 2000-04-26: Michael Norrish: this crashes mosml 1.44 (and 1.99):

datatype 'a result =
    FIRST of 'a
  | SECOND of 'a;
val zz = case FIRST() of
    FIRST _ => ()
  | _ => ();     

while this works:

val z = case SECOND() of
    FIRST _ => ()
  | _ => ();

compiler/Rtvals.sml function prSeq; decode_obj thinks zz is a record
of length 1.  Why?  Has nothing to do with the polymorphism of result.

And really, the *representation* of the result is wrong; here zz
evaluates to false:

datatype result =
    FIRST of int
  | SECOND of int;
val zz = () = (case FIRST 1 of
    FIRST _ => ()
  | _ => ());     

The generated lambda code looks OK:

(prim (set_global Top.zz/3) 
	(prim (ccall2 sml_equal) (BLOCK 0:1 ) 
	      let (BLOCK 0:2 1) in 
	          ((switch:2 var:0 of 
	              0:2 : (BLOCK 0:1 )) 
	            statichandle (BLOCK 0:1 )) 
              end))

But the Kcode is wrong:

(BLOCK 0:1 ); 
push; 
(BLOCK 0:2 1); 
push; 
access 0; 
strictbranchifnot 1; 
branch 2; 
label 2; (BLOCK 0:1 ); 
label 1; pop 1; 
ccall2 sml_equal;
set_global Top.zz/1

Problem: the returned value is the argument of FIRST (which is a block
of length 1 in this case): nothing is pushed between strictbranchifnot
1 and branch 2.  Probably we forget to generate code to put unit in
the accumulator???  Back.sml line 721, optimization for the case where
the else-branch is a constunit ().  In that case, then other branches
are () too (but may have side effects).

The problem is caused by an optimization in the compiler backend, file
compiler/Back.sml line 721.  If you want to get rid of it, uncomment
this code:

         (* if ifnot = Lconst constUnit
            then let val (lbl, C1) = labelCode C
                 in Kstrictbranchifnot lbl :: compexp sz dp ifso C1 end
            else *)

I'm afraid I introduced this optimization in 1997.  The reasoning was
that if some branch of a switch evaluates to () : unit, then all
branches do, and they are evaluated only for their side effects.  Not
so.  

+ 2000-04-26: Constructor ordering.  Constructors should be sorted
alphabetically so that the ordering in datatype declarations doesn't
matter.  That is, this should elaborate:

     signature SIG = 
     sig
	 datatype 'a t = Bt | Ct of int
	 datatype 'a u = Cu of int | Bu 
     end

     structure S: SIG = 
     struct
	 datatype 'a t = Ct of int | Bt
	 datatype 'a u = Bu | Cu of int
     end

     structure G : sig datatype order = EQUAL | GREATER | LESS end = General;
     structure G : sig datatype order = GREATER | EQUAL | LESS end = General;

   - should reorder the pervasive datatypes (order and frag) in Types.sml:

and infoEQUAL = mkSML "EQUAL"
  { conArity=0,   conIsGreedy=false,   conTag=0,   conSpan=3,
    conType=sc_order }
and infoGREATER = mkSML "GREATER"
  { conArity=0,   conIsGreedy=false,   conTag=1,   conSpan=3,
    conType=sc_order }
and infoLESS = mkSML "LESS"
  { conArity=0,   conIsGreedy=false,   conTag=2,   conSpan=3,
    conType=sc_order }
and infoANTIQUOTE = mkSML "ANTIQUOTE"
  { conArity=1,   conIsGreedy=false,   conTag=0,   conSpan=2,
    conType= scheme_1u (fn a =>
      type_arrow a (type_frag a)) }
and infoQUOTE = mkSML "QUOTE"
  { conArity=1,   conIsGreedy=false,   conTag=1,   conSpan=2,
    conType= scheme_1u (fn a =>
      type_arrow type_string (type_frag a)) }

val initial_order_CE = ConEnv [infoEQUAL, infoGREATER, infoLESS];
val initial_frag_CE = ConEnv [infoANTIQUOTE, infoQUOTE];

   - fix the corresponding extraction code in Smlperv.sml:

val [infoFalse, infoTrue] = deConEnv initial_bool_CE
and [infoNil, infoCons]   = deConEnv initial_list_CE   (* NOTE: NOT sorted *)
and [infoNONE, infoSOME]  = deConEnv initial_option_CE
and [infoEQUAL, infoGREATER, infoLESS] = deConEnv initial_order_CE
and [infoANTIQUOTE, infoQUOTE] = deConEnv initial_frag_CE

   - do we need to change only the conTag fields, or also the
     initial_frag_CE etc (as above)?  Better order both.

   - the bool and option datatypes are sorted already

   - we do *not* fix the list datatype, since the constructors
     nil and :: may not be respecified or redeclared.

   - there is no corresponding runtime system code

   - should reorder the constructors in mosmllib:

	open_flag: BasicIO, BinIO, Nonstdio, TextIO
        and runtime/sys.c variable sys_open_flags

	dbresultstatus: Mysql, Postgres
        and dynlibs/mmysql/mmysql.c function db_resultstatus
        and dynlibs/mpq/mpq.c  

	parserInput and parserOutput: Parsing
        and the macroes START, TOKEN_READ, ... in parsing.c

   - mosmlyac must sort the tokens (the token datatype), because the 
     token tags are used as indexes into the parsetable, in parsing.c 
     line 97. 

   - dynlibs/interface/smlside.sml and cside.c: datatype t

   - sort constructors in declarations as well as specifications:
     uncomment line 1865 in Elab.sml, function elabDatBind (this takes 
     care of declarations as well as specifications).  

   - loading of libraries crashes because hashtables
     (Hasht) are used to represent signatures, and the mosmllib stuff 
     was compiled with one constructor ordering in Hasht, and are loaded 
     with another ordering.

   - Sort tokens in the parsers generated by mosmlyac.  Strangely, hand-
     sorting the tokens in compiler/Parser.grm makes mosmlcmp shorter
     by 1 K.  Should do the same to lex/Grammar.grm of course.  How
     make mosmlyac sort tokens?  Tokens are stored in the same
     (hashed, linked) symbol table as other grammar symbols.  The tag
     of a token is used only as an index into the table yytransl, it
     seems (parsing.c line 97).  Hence it suffices to (1) sort the  
     tokens (by symbol_value) and their adapt the indexes (symbol_value). 

   - constructor sorting affects user programs that use 
     Nonstdio.{input_value, output_value}, string_mlval, mlval_string, 
     and hence Polygdbm

Bootstrapping:

(1) Modify the core mosmllib .sml files and recompile.  The new
compiler must be run with a new runtime system.  
(2) Recompile with new compiler and runtime system.  Binaries should be 
identical.
(3) Fix Types and Smlperv.  Does not affect runtime.  Bootstrap.
(4) Enable constructor sorting, reorder Hasht.bucket constructors, 
sort tokens in grammar specifications.
(5) Fix Mysql, Postgres, and their C code.
(6) Fix dynlibs/interface

* Check that it compiles with Solaris, HP-UX, Linux/Alpha, ...

+ Change version to 2.00 (June 2000)

+ Make -quietdec more quiet; drop the welcome greeting.

* New SML Basis Library changes
